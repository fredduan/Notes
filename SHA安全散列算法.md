### SHA安全散列算法

### 发展历史
>安全散列算法（The Secure Hash Algorithm，SHA）由美国国家标准和技术协会（National Institute of Standards and technology，NIST）于1993年提出，并被定义为安全散列标准（Secure Hash Standard，SHS）。SHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512，后四者有时并称为SHA-2。SHA-1在许多安全协定中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5（更早之前被广为使用的杂凑函数）的后继者。但SHA-1的安全性如今被密码学家严重质疑；虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1相似。**这些算法之所以称作“安全”是基于以下两点（根据官方标准的描述）：1、由讯息摘要反推原输入讯息，从计算理论上来说是很困难的。2、想要找到两组不同的讯息对应到相同的讯息摘要，从计算理论上来说也是很困难的。任何对输入讯息的变动，都有很高的机率导致其产生的讯息摘要迥异。** 注意这里说的是 **“很难”** ，而不是不可能。
- SHA-0：初代叫做SHA-0（或FIPS PUB 180），它在发布之后很快就被NSA撤回，并且由1995年发布的修订版本FIPS PUB 180-1（通常称为SHA-1）取代。
- SHA-1：SHA-1和SHA-0的算法只在压缩函数的讯息转换部份差了一个位元的循环位移。根据NSA的说法，它修正了一个在原始算法中会降低杂凑安全性的弱点。然而NSA并没有提供任何进一步的解释或证明该弱点已被修正。而后SHA-0和SHA-1的弱点相继被攻破，SHA-1似乎是显得比SHA-0有抵抗性，这多少证实了NSA当初修正算法以增进安全性的声明。SHA-0和SHA-1可将一个最大2的64位元的讯息，转换成一串160位元的讯息摘要；其设计原理相似于MIT教授Ronald L. Rivest所设计的密码学杂凑算法MD4和MD5。
- SHA-2：NIST发布了三个额外的SHA变体，这三个函数都将讯息对应到更长的讯息摘要。以它们的摘要长度（以位元计算）加在原名后面来命名：SHA-256，SHA-384和SHA-512。它们发布于2001年的FIPS PUB 180-2草稿中，随即通过审查和评论。包含SHA-1的FIPS PUB 180-2，于2002年以官方标准发布。2004年2月，发布了一次FIPS PUB 180-2的变更通知，加入了一个额外的变种SHA-224"，这是为了符合双金钥3DES所需的金钥长度而定义。SHA-256和SHA-512是很新的杂凑函数，前者以定义一个word为32位元，后者则定义一个word为64位元。它们分别使用了不同的偏移量，或用不同的常数，然而，实际上二者结构是相同的，只在循环执行的次数上有所差异。SHA-224以及SHA-384则是前述二种杂凑函数的截短版，利用不同的初始值做计算。这些新的杂凑函数并没有接受像SHA-1一样的公众密码社群做详细的检验，所以它们的密码安全性还不被大家广泛的信任。Gilbert和Handschuh在2003年曾对这些新变种作过一些研究，声称他们没有找到弱点。

> 在CRYPTO 98上，两位法国研究者提出一种对SHA-0的攻击方式：在261的计算复杂度之内，就可以发现一次碰撞（即两个不同的讯息对应到相同的讯息摘要）；这个数字小于生日攻击法所需的2的80次方，也就是说，存在一种算法，使其安全性不到一个理想的杂凑函数抵抗攻击所应具备的计算复杂度。2004年时，Biham和 Chen也发现了SHA-0的近似碰撞，也就是两个讯息可以杂凑出几乎相同的数值；其中162位元中有142位元相同。他们也发现了SHA-0的完整碰撞（相对于近似碰撞），将本来需要80次方的复杂度降低到62次方。2004年8月12日，Joux, Carribault, Lemuet和Jalby宣布找到SHA-0算法的完整碰撞的方法，这是归纳Chabaud和Joux的攻击所完成的结果。发现一个完整碰撞只需要251的计算复杂度。他们使用的是一台有256颗Itanium2处理器的超级电脑，约耗80,000 CPU工时。2004年8月17日，在CRYPTO 2004的Rump会议上，王小云，冯登国、来学嘉，和于红波宣布了攻击MD5、SHA-0 和其他杂凑函数的初步结果。他们攻击SHA-0的计算复杂度是2的40次方，这意谓的他们的攻击成果比Joux还有其他人所做的更好。请参见MD5 安全性。2005年二月，王小云和殷益群、于红波再度发表了对SHA-0破密的算法，可在2的39次方的计算复杂度内就找到碰撞。鉴于SHA-0的破密成果，专家们建议那些计划利用SHA-1实作密码系统的人们也应重新考虑。在2004年CRYPTO会议结果公布之后，NIST即宣布他们将逐渐减少使用SHA-1，改以SHA-2取而代之。2005年，Rijmen和Oswald发表了对SHA-1较弱版本（53次的加密循环而非80次）的攻击：在2的80次方的计算复杂度之内找到碰撞。2005年二月，王小云、殷益群及于红波发表了对完整版SHA-1的攻击，只需少于2的69次方的计算复杂度，就能找到一组碰撞。（利用生日攻击法找到碰撞需要2的80次方的计算复杂度）。这篇论文的作者们写道；“我们的破密分析是以对付SHA-0的差分攻击、近似碰撞、多区块碰撞技术、以及从MD5算法中寻找碰撞的讯息更改技术为基础。没有这些强力的分析工具，SHA-1就无法破解。”此外，作者还展示了一次对58次加密循环SHA-1的破密，在2的33次方个单位操作内就找到一组碰撞。完整攻击方法的论文发表在2005年八月的CRYPTO会议中。殷益群在一次面谈中如此陈述：“大致上来说，我们找到了两个弱点：其一是前置处理不够复杂；其二是前20个循环中的某些数学运算会造成不可预期的安全性问题。”。2005年8月17日的CRYPTO会议尾声中王小云、姚期智、姚储枫再度发表更有效率的SHA-1攻击法，能在2的63次方个计算复杂度内找到碰撞。2006年的CRYPTO会议上，Christian Rechberger和Christophe De Cannière宣布他们能在容许攻击者决定部分原讯息的条件之下，找到SHA-1的一个碰撞。

在密码学的学术理论中，任何攻击方式，其计算复杂度若少于暴力搜寻法所需要的计算复杂度，就能被视为针对该密码系统的一种破密法；但这并不表示该破密法已经可以进入实际应用的阶段。就应用层面的考量而言，一种新的破密法出现，暗示着将来可能会出现更有效率、足以实用的改良版本。虽然这些实用的破密法版本根本还没诞生，但确有必要发展更强的杂凑算法来取代旧的算法。在“碰撞”攻击法之外，另有一种反译攻击法（Pre-image attack），就是由杂凑出的字串反推原本的讯息；反译攻击的严重性更在碰撞攻击之上，但也更困难。在许多会应用到密码杂凑的情境（如用户密码的存放、文件的数位签章等）中，碰撞攻击的影响并不是很大。举例来说，一个攻击者可能不会只想要伪造一份一模一样的文件，而会想改造原来的文件，再附上合法的签章，来愚弄持有私密金钥的验证者。另一方面，如果可以从密文中反推未加密前的使用者密码，攻击者就能利用得到的密码登入其他使用者的帐户，而这种事在密码系统中是不能被允许的。但若存在反译攻击，只要能得到指定使用者密码杂凑过后的字串（通常存在影档中，而且可能不会透露原密码资讯），就有可能得到该使用者的密码。

### 基本概念
>散列算法：用来产生一些数据片段（例如消息或会话项）的散列值的算法。好的散列算法具有在输入数据中的更改可以更改结果散列值中每个比特的特性；因此，散列对于检测在诸如消息等大型信息对象中的任何变化很有用。此外，好的散列算法使得构造两个独立的有相同散列的输入不能通过计算方法实现。典型的散列算法包括 MD2、MD4、MD5 和 SHA-1。散列算法也被称为散列函数。散列算法的算法就是争取一个萝卜一个坑的原则。比如说有5个数 12,25,30,45,50,这几个数有个规律,就是十位数都不相同,如果我设置一个散列函数f（value）=value/10;平常的时候,我们查找50，要比较5次（其他算法可能不同）,这里用散列算法只需要1次,就是解散列函数,key=50/10=5,要找的数就在第5个位子.但是上面问题还是很多的,比如说查找55呢?就会出错<因为55解散列函数之后,也是在第5个位子>,还有等等等问题,很显然这个是我散列函数没设置好,当你把散列函数设置好了后,由于数据的庞大,冲突很有可能产生,那么就需要我们来处理冲突了,**所以写散列算法就是设置好的散列函数和处理冲突的过程**.这里散列算法涉及的查找就跟查找的数量无关,跟冲突率有直接的关系。

在信息安全技术中，经常需要验证消息的完整性，散列（Hash）函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的“散列”或“消息摘要”（Message digest）。散列函数把消息或数据压缩成摘要，使得数据量变小。所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的。但也可能不同，这种情况称为“散列碰撞”，这通常是两个不同长度的散列值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。典型的散列函数都有无限定义域，比如任意长度的字节字符串，和有限的值域，比如固定长度的比特串。在某些情况下，散列函数可以设计成具有相同大小的定义域和值域间的一一对应。一一对应的散列函数也称为排列。可逆性可以通过使用一系列的对于输入值的可逆“混合”运算而得到。由于散列函数的应用的多样性，它们经常是专为某一应用而设计的。例如，加密散列函数假设存在一个要找到具有相同散列值的原始输入的敌人。一个设计优秀的加密散列函数是一个“单向”操作：对于给定的散列值，没有实用的方法可以计算出一个原始输入，也就是说很难伪造。为加密散列为目的设计的函数，如MD5，被广泛的用作检验散列函数。这样软件下载的时候，就会对照验证代码之后才下载正确的文件部分。比如linux中的“sha256sum -c file.sha256”命令。此代码有可能因为环境因素的变化，如机器配置或者IP地址的改变而有变动。以保证源文件的安全性。一个安全的哈希函数H必须具有以下属性：
- l）H能够应用到大小不一的数据上。
- 2）H能够生成大小固定的输出。
- 3）对于任意给定的x，H（x）的计算相对简单。
- 4）对于任意给定的代码h，要发现满足H（x）=h的x在计算上是不可行的。
- 5）对于任意给定的块x，要发现满足H（y）=H（x）而y=x在计算上是不可行的。
- 6）要发现满足H（X）=H（y）的（X，y）对在计算上是不可行的

### SHA-1算法
在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位（bit）作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下：“01100001 01100010 01100011”。这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。
1. **补位**：消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。在“abc”的例子中，先在右边补一个“1”，然后在“1”后面补423个“0”。这样就一共是24+1+423=448位。
2. **补长度**：所谓的补长度是将原始数据的长度（补位前的长度）补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。这样，加上64位的“长度”，现在的消息就是512的整倍数。
3. **初始化缓存**：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。该缓存表示为A=0x6A09E667 , B=0xBB67AE85 , C=0x3C6EF372 , D=0xA54FF53A, E=0x510E527F , F=0x9B05688C , G=0x1F83D9AB , H=0x5BE0CD19 。
4. **常量和函数**:
>一系列的常量字K(0),K(1), ... , K(79)，如果以16进制给出。它们如下：
```
Kt = 0x5A827999 (0<= t <= 19)

Kt = 0x6ED9EBA1 (20<= t <= 39)

Kt = 0x8F1BBCDC (40<= t <= 59)

Kt = 0xCA62C1D6 (60<= t <= 79).
```
>在SHA1中我们需要一系列的函数。每个函数ft (0 <= t <= 79)都操作32位字B，C，D并且产生32位字作为输出。ft(B,C,D)可以如下定义
```
ft(B,C,D) = (B AND C) or ((NOT B) AND D) ( 0 <= t <= 19)

ft(B,C,D) = B XOR C XOR D (20 <= t <= 39)

ft(B,C,D) = (B AND C) or (B AND D) or (C AND D) (40 <= t <= 59)

ft(B,C,D) = B XOR CXOR D (60 <= t <= 79).
```
5. **计算消息摘要**：必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第二个5个字(1个字32bit)的缓冲区被标识为H0,H1, H2, H3, H4。80个字的缓冲区被标识为W0,W1,..., W79。另外还需要一个一个字的TEMP缓冲区。为了产生消息摘要，在第2部分中定义的16个字(1个字32bit)的数据块M1,M2,..., Mn会依次进行处理（一个数据块512bit），处理每个数据块Mi 包含80个步骤。在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制）
```
H0 = 0x67452301

H1 = 0xEFCDAB89

H2 = 0x98BADCFE

H3 = 0x10325476

H4 = 0xC3D2E1F0.
```
6. **处理数据块Mi**：现在开始处理M1, M2,... , Mn。为了处理 Mi,需要进行下面的步骤
- (1). 将Mi 分成 16 个字 W0, W1, ... , W15,W0 是最左边的字
- (2). 对于t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).
- (3). 令A = H0, B = H1, C = H2, D = H3, E = H4.
- (4) 对于t = 0 到 79，执行下面的循环
```
TEMP = S5(A) +ft(B,C,D) + E + Wt + Kt;
E = D; D = C; C =S30(B); B = A; A = TEMP;
## S是循环左移函数，Sn表示左移n位。
```
- (5). 令H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.

在处理完所有的 Mn, 后，消息摘要是一个160（32bit X 5）位的字符串，以下面的顺序标识：H0 H1 H2 H3 H4.

### SHA-256算法
SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。步骤与SHA-1类似，不同点是位运算的函数和顺序。
