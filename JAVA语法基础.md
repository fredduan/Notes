# Java语法基础
****
## 一、Java关键字
<font color=#FF4500>Java关键字全部是小写的</font>  
| 关键字 |作用   |
|:-------|:---:|
|class|类|
|extends|类的继承|
|implement|对接口的实现|
|interface|定义接口|
|import|导入jar包|
|package|使作用的类包含如某jar包中|
|break|跳出某个域，带标签的break会中断并跳出该标签所指的循环|
|case|switch语句分支条件|
|continue|跳出本次循环，带标签的continue会到达标签的位置|
|default|switch语句中用于标志当默认条件成立时怎么办|
|do|do while语句|
|if|条件判断语句，判读条件为真时怎么办|
|else|条件判断语句，判断条件为假时怎么办|
|for|标志循环控制语句|
|return|标志跳出当前方法，return下面的语句不会执行|
|switch|标志分支语句|
|while|标志while循环控制语句|
|false|逻辑假|
|true|逻辑真|
|null|空值，对象默认初始化时赋值为null|
|boolean|布尔类型，8个基本数据类型之一，1个字节|
|byte|字节型，8个基本数据类型之一，1个字节|
|char|字符型，8个基本数据类型之一，2个字节|
|short|短整型，8个基本数据类型之一，2个字节|
|int|整型，8个基本数据类型之一，4个字节|
|long|长整型，8个基本数据类型之一，8个字节|
|float|单精度浮点型，8个基本数据类型之一，4个字节|
|double|双精度浮点型，8个基本数据类型之一，8个字节|
|try||
|catch||
|throw||
|throws||
|finally||
|abstract|定义抽象类和抽象方法|
|final|final修饰的类不能被继承，final修饰的方法不能被覆盖，final修饰的变量一旦赋值不能重新赋值（常量）|
|nativ||
|private|访问权限修饰符，private的成员只有本类中能访问|
|protected|访问权限修饰符，protected的成员可以被子类访问，也可以被同一个包中访问（包访问权限，该权限没有修饰符，只要缺省就可以了）|
|public|访问权限修饰符，public的成员谁都可以访问|
|static|静态修饰符|
|synchronized||
|transient||
|volatile||
|instanceof|逻辑判断修饰符，a instanceof A 表示若a对象是A类的对象，则返回值为true，否则false|
|new|标志创建新对象|
|super|子类对父类的被重写的成员方法调用或父类构造器调用时使用|
|void|标志方法的返回类型为空|
|assert||
|enum|枚举类型，写在类声明时类名的前面，例如public enum Spiciness{NOT, MILD,MEDIUM,HOT,FLAMING}|
|goto|循环控制标识符，没用|
|const||

- **static**：static修饰符用来解决两种问题：
- - 一是只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。
- - 二是希望某个方法不与包含他的类的任何对象关联在一起。也就是说即使没有创建对象，也能够调用这个方法。
- - 当一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。
- - 引用static字段或方法有两种办法，一种是通过一个对象去调用它（对象名.），一种是直接用类名直接引用（类名.），因此static的方法又称为”类方法“
- - static字段对每个类来说都只有一份存储空间，即不管创建多少个对象，这些对象的那个static字段的值都是统一的；而非static字段则是对每一个对象有一个存储空间。
- - static方法的内部不能调用非static的方法。JAVA禁止使用全局方法，但你在类中置入static方法就可以访问其他static方法或static域。
- - static区域中无法直接访问成员变量（非static变量）。如果想要让static方法访问成员变量，要么给成员变量加上static，要么把方法的static去掉。
- - 静态关键字不能应用于局部变量。
- - java允许将多个静态初始化动作组成一个特殊的”静态子句“，或叫做”静态块“，例如static{i=47;}，这段代码仅执行一次：当首次生成包含这个静态块的类的对象时，或首次访问属于这个类的静态数据成员（字段）时。非静态变量的初始化就直接用{}括起来，不需要关键字。
  

- **this**：
- - this关键字只能在方法内部使用，它是个代词，指代的是调用这个方法的对象。就是说加入有一个方法f(){this++；}，一个int对象a,然后a对象调用了方法f()，即a.f()，那么方法f()里的this指代的就是a，a调用方法f()就得到a自加1。
- - static方法里是不能使用this的


- **final**：
- - final数据：
- - - 一个既是static又是final的域只占据一段不能改变的存储空间。当final作用的是基本类型时，final使数值恒定不变（常量），这种情况必须在定义常量时赋值（初始化）；当final作用的是对象的引用时，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法把它再指向另一个对象，但是对象自身是可以改变的，Java并没有提供任何使对象恒定不变的途径。因为是常量，所以引用一般用全部字母大写表示，必须在域的定义处或者每个构造器中用表达式对final的引用所指的对象初始化。
- - - final还可以用在方法的参数列表中，final的参数无法在方法中更改参数引用所指向的对象。
- - final方法：
- - - final方法会被锁定，任何继承类中不能修改基类的final方法，即不能覆盖。
- - - 类中所有private的方法都隐式地指定为final方法，由于无法在类的外面（甚至是继承类中）调用private方法，所以也就无法覆盖它。对private方法加上final修饰，不会有任何额外的效果。
- - - 去覆盖一个final方法，或private方法时，不会报错，但实际上没有覆盖成功，而是新建了一个与该方法同名但作用不同的方法。
- - final类：
- - - 定义一个类为final时，表明任何人都不能继承这个类。

## 二、变量
<font color=#9ACD32>对象即是变量。</font>变量是java中最基本的单元，由四个要素组成：变量名、变量数据类型、存储单元、变量值。
<font color=#FF4500>一个变量声明后必须初始化。</font>JAVA尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的**局部变量**，Java以编译时报错的形式来贯彻这种保证。而在类中定义一个对象引用时，如果不将其初始化，此引用就会被默认初始化。
- 局部变量：局部变量就是域中的变量，即{}内的变量。
- 初始化：
- - 无法阻止初始化的进行，它将在构造器被调用前发生。
- - 初始化的顺序是先静态对象，而后非静态对象。
- - 如果想要给某个类的每个对象的一个成员变量赋相同的值，就在类中定义成员变量时直接赋值。
- - 数组的初始化要用{ }括起来，中间用“，”分隔，}后面的；不要忘了。
- - JVM会在给对象分配空间后，为这个空间清零，所以所有变量都是默认初值，这会发生在一切初始化之前。
- - “继承类调用基类的构造器”发生在“继承类初始化”之前。所以在构造器中调用成员方法的危险在于：若该成员方法需要依靠继承类的变量的初始化进行操作。当基类构造器调用该成员方法时，这个成员方法所依赖的继承类变量还没来得及初始化，这个变量还只是默认值。
- 数组：
- - 如果一个数组还不知道每个元素需要使是什么类型的，或者每个元素的类型不一致，可以在创建一个object类的对象，因为所有类都是继承自object类的，那一个object数组的元素可以随意是任何类型，例如Object[] ob = {new A(), new B(), new C()};
- static变量和非static变量：
- - 非static变量叫成员变量。某一个对象中的成员变量的改变不会影响到另一个对象中的成员变量的改变。
- - static声明的变量，所有通过该类new出的对象，都可以共享，通过该对象都可以直接访问static声明的变量，也可采用类直接访问，所以我们也称其为类变量。
- - static 声明的变量会放到方法区中，static 声明的变量只初始化一次，加载类的时候初始化，如果多个静态变量，会按照静态变量在类中的顺序进行初始化。 

## 三、底层
- 堆：存放所JAVA对象，或者说所有用“new”创建的对象
- 栈：存放基本类型的对象，这种对象创建的时候不需要用“new”关键字，直接char c = 's';而所谓包装器类就是用来让一个本来是基本类型的对象变成一般对象，存在堆中，例如Character ch = new Character();

## 四、数据类型
JAVA中有两种数据类型：基本类型和非基本类型，非基本类型就是其他人或自己创建的类，本质上基本类型和非基本类型没有什么不同。
| 基本类型 |大小   |包装器类型|
|:-:|:-:|:-:|
|boolean|-|Boolean|
|char|16bits|Character|
|byte|8bits|Byte|
|short|16bits|Short|
|int|32bits|Integer|
|long|64bits|Long|
|float|32bits|Float|
|double|64bits|Double|
|void|-|Void|
除了以上9种基本类型外，非基本类型中有两种类包含的方法，提供的操作与对基本类型能执行的操作一样：
- BigInteger：支持任意经度的整数，在运算中多大的数都不会溢出
- BigDecimal：支持任何经度的定点数，可以用它进行精确的货币计算

基本类型有两种转换，默认转换和强制转换：
- 默认转换：容量小的类型会默认转换为大的类型
- - byte->short(char)->int->long->float->double
- - byte，short，char直接计算时会统一首先转换成int
- 强制转换：容量大的类型向容量小的类型转换
- - 语法为（类型）变量名
  
<font color=#FF4500>多种类型混合运算时会将所有变量转换成运算中最大的类型后，再运算</font>

## 五、循环控制语句
- swith（）的参数（括号里的变量）只能是char、byte、short、int类型
- 循环控制语句的statement如果只有一行（即一个；就结束的语句），是可以不用{}把statement括起来的。
- foreach语句：for(float x : f)，f是一个float数组，x从头到尾遍历f数组的元素，第一次循环时，x引用f数组的第一个元素，以此类推

## 六、类

## 七、对象
- 作用域：就是{}里的范围内。对象的引用（例如{String s = new String("s is a string")}）中的s在{}外调用时，JVM不知道是什么东西，但s指向的这个String对象在内存里还是存在的，这就是为什么要有垃圾回收器。
- 对一个对象进击操作时，我们真正操作的是对对象的引用。比如Science s = new Science();中的s只是一个引用，真正的对象是s引用所指的内存中的一段空间和空间中的值。
## 八、方法
- int x=a.f(); 调用方法的行为通常被称为<font color=#0099FF>发送消息给对象</font>，f()称为消息，a是对象。
- 方法的返回值可以是基本类型和引用类型，或者返回值为空void。若不是void则方法体中需要用return来结束并返回，return后面的语句不会被执行。
- 构造器：
- - 构造器是一种特殊的方法，因为它没有返回值。
- - 即使没有显式地使用static关键字，构造器实际上也是静态方法。
- - 编写构造器时的一条准则：用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法。在构造器中唯一能够安全调用的方法是基类中的final（private属于final）方法。
- 方法的重载（overload）
- - JAVA用方法的参数类型列表区分同名方法
- - 但是想用方法的返回值类型来区分同名方法是行不通的
- - 方法的重载只能发生在同一个类的内部

## 九、清理
- 垃圾回收器：
- - 垃圾回收器只知道释放那些经由new分配的内存，所以基本类型的对象是不会被垃圾回收器清理的。
  
- finalize方法：
- - 只有一种情况是垃圾回收器处理不了的，那就是通过某种new方式以外的方式为对象分配了存储空间。这种情况的出现是由于”本地方法“的使用。本地方法只支持C和C++，但它们可以调用其他语言写的代码，所以实际上可以使用任何代码。当这些代码人为的主动为对象分配存储空间时，就必须要用finalize方法去清理。
- - 你应该总是假设基类版本的finalize方法也要做些重要的事情，因此要使用super来调用它

## 十、访问权限
- 域和方法的访问权限：
- - public权限：随处可用
- - protected权限：派生类中可用+同一包中可用
- - 包访问权限：同一包中可用
- - private权限：同一类中可用
- 类的访问权限：
- - 每个编译单元（文件）都只能有一个public类，意味着每个编译单元都有单一的公共接口。
- - 类的访问权限只有public权限和包访问权限两种，类不能是private的也不能是protected的。
- 想访问某类中某成员的方法：
- - 使该成员成为public
- - 把想要访问这个成员的编译单元放到跟这个成员所在类同一个包中，再给这个成员加上包访问权限
- - 给这个成员赋上protected权限，然后创建一个类，这个类继承那个成员所在的类
- - 最好的方法：为这个成员提供访问器（accessor）和变异器（mutator），也叫做set和get方法，以读取或改变该成员

## 十一、继承
- 导出类继承了基类所有的方法和域，<font color=#FF4500>但是基类的构造器不会被继承。</font>当创建导出类B的对象b时，对象b中实际上包含了一个基类A的子对象。由于构造器不会被继承，所以b.A()这种是不行的。对象b里面已经包含了一个A的子对象了，没法再调用A的构造器A()来再创建。
- 基类的构造器总是在导出类的构造过程中被调用，而且按照集成层次逐渐向上连接，以使每个基类的构造器都能得到调用。这样做的意义是，构造器有一项特殊任务：检查对象是否被正确地构造。导出类只能访问它自己的成员，不能访问基类中的成员（基类成员通常是private类型）。只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化。因此，必须令所有构造器都得到调用，否则就不可能正确构造完整对象。这就是为什么编译器要强制每个导出类部分都必须调用构造器的原因。在导出类的构造器主体中，如果没有明确指定调用某个基类构造器，它就会调用默认构造器，但如果没有默认构造器，编译器就会报错。
- 方法覆盖（override）：子类方法覆盖基类方法时，方法名、返回类型、参数列表必须完全一样，不然就不是覆盖，而是重名方法。

## 十二、多态
- <font color=#9ACD32>Java的多态这种特征，实际上是由继承、方法覆盖、向上转型、动态绑定这4个东西带来的。</font>
- 多态通过分离**做什么**和**怎么做**，从另一角度将接口和实现分离开来。
- 多态的作用是消除类型之间的耦合关系，耦合关系是指两个事物间具有相互作用或相互影响的关系。
- 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们是从同一基类导出而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过一个基类来调用。
- 绑定：将一个方法调用同一个方法主体关联起来被称为绑定。
- - 若在程序执行前进行绑定（由编译器和连接程序实现），叫做前期绑定；若在运行时根据对象的类型进行绑定，叫做后期绑定（或动态绑定或运行时绑定）。
- - Java中除了static方法和final方法（private方法属于final方法）外，其他方法都是后期绑定。所以static方法和final方法不具有多态性。由于构造器这种方法实际上是static方法，所以它也不具有多态性。
- - 既然方法都是后期绑定，我们就可以编写只与基类打交道的代码就行了，然后在运行时让对象自己去判断应该跟哪个方法主体去绑定，或者说调用方法时到底用的是哪个方法主体。
- 一种Java中难易发现的隐藏错误（TIJ-P163）：
- - 如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而，这个调用的效果可能相当难以预料，因为被覆盖的方法在对象被完全构造之前就会被调用。
- - 在任何构造器内部，整个对象可能只是部分形成--我们只知道基类子对象已经进行初始化。如果构造器只是在构建对象过程中的一个步骤，并且该对象所属的类是从这个构造器所属的类导出的，那么导出部分在当前构造器正在被调用的时刻仍旧是没有被初始化的。然而，一个动态绑定的方法调用却会向外深入到继承层次结构内部，它可以调用导出类里的方法。如果我们是在构造器内部这样做，那么就可能会调用某个方法，而这个方法所操纵的成员可能还未进行初始化--这肯定会招致灾难。
- - 初始化的实际过程是：1）在其他任何事发生之前，将分配给对象的存储空间初始化成二进制的零。2）调用基类构造器。3）按照声明的顺序调用成员的初始化方法。4）调用导出类的初始化主体。

## 设计模式
- 设计模式是可以重复利用的解决方案
- 设计模式从结构上分为三类：创建型、结构型、行为型
- 单例模式：让一个类永远只能存在一个实例
- - 单例模式三要素：
- - - 在类体重需要具有静态的私有的本类型的变量
- - - 构造器必须是私有的
- - - 提供一个公共的静态的入口点方法
